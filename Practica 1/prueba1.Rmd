---
title: "Picatoste_preproceso"
author: "Alvaro Picatoste"
date: "9 de marzo de 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Practica 1

1-. Cargar el fichero de datos en R. Antes de cargar el fichero, se debe inspeccionar que tipo de formato csv es para realizar la lectura apropiada.

```{r}
#Valor decimal separado por "." -> sistema ingles -> read.csv en vez de read.csv2
data <- read.csv("2016_raw.csv")
```

2-. Cambiar los nombres de las variables que son muy largos por otros mas cortos (al final del documento se especifica como).

```{r}
#Creo una funcion que inspecciona un vector y si contiene nombres separados por "." acorta automaticamente siguiendo las instrucciones del enunciado.
  
  short.variables <- function(input1, ...){
  for (i in 1:length(input1)){
  if (!grepl("\\.", (input1)[i])) {
    next } 
    else { 
      separate.words <- strsplit(input1[i], "\\.")
      number.of.words <- length(separate.words[[1]])
      mystring <- c()
      for (jj in 1:number.of.words){
        myletter <- substr(separate.words[[1]][jj], 1,1)
        mystring <- c(mystring, myletter)
      }
      input1[i] <- paste(mystring, collapse = "")
      }
    }
  return(input1)  
  }
  
  #Aplico la funcion al vector que contiene el nombre de las variables
  long_names <- names(data) 
  short_names <- short.variables(long_names)
  names(data) <- short_names
  names(data)
```

3. Indicar el tipo de variable estadistica de cada variable.
4. En el caso en que R no haya asignado el tipo apropiado a una variable, realizar la conversión necesaria para que el tipo final de cada variable sea el adecuado.
5. Corregir errores de variables cuantitativas con confusión de separador decimal.

```{r}
#Estudio si las variables son categoricas-cualitativas(nominal u ordinal) o cuantitativas (discreta o continua). Por analisis de las variables analizo cómo deberían ser y realizo las conversiones pertinentes (ejercicios 3, 4 y 5 realizados conjuntamente)

  sapply(data, class)

#Estudio de como tienen que ser las variables:

  cco <- "Categorica-cualitativa-ordinal"
  ccn <- "Categorica-cualitativa-nominal"
  cnd <- "Cuantitativa Discreta"
  cnc <- "Cuantitativa Continua"
  mis_categorias <- c(ccn, ccn, cco, cnc, cnc, cnc, cnc, cnc, cnc, cnc, cnc, cnc, cnc)
  mydf <- as.data.frame(setNames(mis_categorias, names(data)))
  mydf

#Se observa que: 
  
# Happiness Rank aparece como cuantitativa numerica pero debera ser cualitativa ordinal.
# Happiness Score aparece como categorica pero debera ser numerica decimal.
# GDP per capita aparece como categorica pero debera ser numerica decimal.
  
  #Para convertir HS a numerico es necesario corregir los errores de separadores decimales por lo que el ejercicio 5 se realiza en este punto.
  
  data$HS <- as.character(data$HS)
  data$HS <- data$HS <- gsub(",", ".", data$HS)
  data$HS <- as.numeric(data$HS)
  
  data$GpC <- as.character(data$GpC)
  data$GpC <- data$GpC <- gsub(",", ".", data$GpC)
  data$GpC <- as.numeric(data$GpC)
  
  data$HR <- as.ordered(data$HR)
  
#Comprobamos que las variables han sido correctamente convertidas:
  
  str(data)
  
#Se comprueba además en relación al ejercicio 5 que no hay ningún separador decimal erroneo:
  comprobacion <- lapply(data[4:ncol(data)], function(x) any(grepl(",", x)))
  comprobacion
  
```

6. Normalizar/Estandardizar variables cualitativas.

```{r}
# La funcion EstandarFOR estandariza variables cualitativas según indicado en enunciado. En caso de que haya una palabra entre paréntesis también la convertirá a mayúsculas.

  EstandarFOR <- function(x) {
      s <- strsplit(x, " ")[[1]]
      for (i in 1:length(s)) {
        if (s[i] != "and") {
          ss <- strsplit(s[i], "")[[1]]
          if (ss[1] == "(") {
            s[i] <- paste(substring(s[i],1,1), toupper(substring(s[i],2,2)), substring(s[i], 3),
                          sep="", collapse=" ")
          } else {s[i] <- paste(toupper(substring(s[i], 1,1)), substring(s[i], 2), sep="", collapse=" ")}
        } else { next(i) }
      } 
      return(paste(s, sep="", collapse=" "))
    }

    data$Country <- trimws(data$Country)
    data$Country <- sapply(data$Country, EstandarFOR)
    data$Country <- as.factor(data$Country)
    head(data$Country)
    
    #Corregimos las categorias de la variable Region
    data$Region <- trimws(data$Region)
    data$Region <- gsub("SUB-SAHARAN  AFRCA", "SUB-SAHARAN AFRICA", data$Region)
    data$Region <- gsub("MIDDLE EAST AND NORTHERN  AFRCA", "MIDDLE EAST AND NORTHERN AFRICA", data$Region)
    data$Region <- as.factor(data$Region)
    levels(data$Region)
    
```
7. Revisar posibles inconsistencias entre variables.
    i. Lower.Confidence.Interval vs Upper.Confidence.Interval
    ii. Happiness.Rank vs Happiness.Score
    
```{r}
 
# Se observa que hay valores en los que LCI es mayor a UCI. Se sustituyen de acuerdo a enunciado.

   a <- which(data$LCI > data$UCI)
   fromLCItoUCI <- data$LCI[a]
   fromUCItoLCI <- data$UCI[a]
   data$LCI[a] <- fromUCItoLCI
   data$UCI[a] <- fromLCItoUCI
   which(data$LCI > data$UCI)
   
# Se onservan incongruencias con respecto al Rank respecto al Score. Se corrige el Ran de acuerdo al Score.
   
   data$HR <- order(data$HS, decreasing = TRUE)
    
```   

8. Buscar valores atípicos en las variables cuantitativas
    i. Presentar un boxplot para cada variable cuantitativa.
    ii. Realizar un cuadro con las estimaciones robustas y no robustas de tendencia central y dispersión
    de cada variable cuantitativa.

```{r}
 
  library(psych)

  #Representación de un BOXplot para cada variable (Agrupadas en variables con similares escalas para facilidad de analisis)
   
  boxplot(data[,4:6])
  boxplot(data[,c(7:9,13)])
  boxplot(data[,10:12])
   
  #Tabla con estimadores
  
  medidasROBUSTAS <- function(x) {
     myvalues <- c(mean(x, na.rm = TRUE), median(x, na.rm = TRUE), mean(x, na.rm = TRUE, trim=), winsor.mean(x, na.rm = TRUE, trim=), sd(x, na.rm = TRUE),   IQR(x, na.rm = TRUE),  mad(x, na.rm = TRUE))
     return(myvalues)
    }

    mytable <- round(sapply(data[,4:ncol(data)],medidasROBUSTAS),3)
    medidas <- c("Media", "Mediana", "Media Recortada", "Media winsorizada", "Desviacion estandar", "Rango Intercuartilico (PIC)", "Desviación absoluta DAM")
    dimnames(mytable)[[1]] <- medidas
    mytable

```   
  
 9. Valores perdidos.
 
      i. Buscar qué variables y registros tienen valores perdidos.
      ii. Imputar los valores a partir de los k-vecinos más próximos usando la distancia de Gower con la
      información de les 6 últimas variables.

```{r}
 
 #Busco NAs por columnas
    
   mycolswNA <-  colnames(data)[colSums(is.na(data)) > 0]
   myrowswNA <-   which(rowSums(is.na(data)) > 0)
   
   sprintf("En la columna/columnas - %s - hay Valores perdidos. En las fila/filas - %s - hay valores perdidos", mycolswNA, myrowswNA)
   
    
```  

10. Finalmente, realizar un breve estudio descriptivo de los datos una vez depurados y crear el fichero de
    datos corregido.

```{r}

#


#Generamos el archivo en la misma ubicacion que el proyecto:

   write.csv(data, file = "2016_preprocessed.csv")

    
``` 
